%Code that solves the Fractional Neutron Point Kinetics (FNPKE) for 
%ramp insertions.

%Authors: Cruz-LÃ³pez C.-A. (cacl.nucl@gmail.com)
%         Espinosa-Paredes G. (gepe@xanum.uam.mx)
format long g

%*******************************************************************
%************************** Input **********************************
%fractional order 
alpha_f = 1;

%Vector with the standard decay lambda constants of the precursors
L=[0.0127 0.0317 0.115 0.311 1.4 3.87];

%Betas
Betas =[0.000266,0.001491, 0.001316, 0.002849, 0.000896, 0.000182];

%Lambda
%mean generation time between the birth of a neutron and its subsequent absorption-inducing fission
Lambda_U=0.00002;

% These lines do not need to be modified.
%Lambda_U^alpha,lambda^alpha 
L_f = L.^alpha_f;
LAM_f = Lambda_U^alpha_f;

%Fractional Initial conditions
n0 = 1;
C0 = (n0/LAM_f)*Betas./L_f

% Target = upper limit of the interval
% step is the size of the elements in which the time is divided
Target = 10
step = 0.0001

% Slope of the linear reactivity
Rampa = 0.1

% *************************Solver *********************************
% Solution_n is a vector where the solution will be saved
Solution_n = [ ]

% Calling the Ramp function that solves the neutron density as well
% as the concentration of the precursors of the delayed nuetrons, conside
% -ring a rectivity given by rho(t)=gamma*t
Solution_n=Ramp(Target,L_f,LAM_f,Betas,step,Rampa,alpha_f,C0);

% Name of the .xlsx that is generated by the code
filename = 'Output_ramp.xlsx',alpha_f;
xlswrite(filename,Solution_n)


% ************************* Polynomials ****************************
% ******************************************************************
% ******************************************************************
% ************************  P_f(s)    *******************************
function P1 = Poly_Coeff(L_f,LAM_f,rho,Betas)
C_P = [ ];
bet_tot = sum(Betas);
u = (rho-bet_tot)/LAM_f;
C_P(1:3)=[1 Suma(1,L_f)-u Suma(2,L_f)-u*Suma(1,L_f)-(1/LAM_f)*dot(L_f,Betas)];

for i=3:size(L_f,2)
    s1 = 0;
    for j=1:size(L_f,2)
        s1 = s1+L_f(j)*Betas(j)*Sumai(j,i-2,L_f);
    C_P(i+1)=Suma(i,L_f)-u*Suma(i-1,L_f)-(1/LAM_f)*s1;
    end
end
s2=0;
for k=1:size(L_f,2)
    s2 = s2+L_f(k)*Betas(k)*Sumai(k,size(L_f,2)-1,L_f);
end
C_P(size(L_f,2)+2)=-u*Suma(size(L_f,2),L_f)-(1/LAM_f)*s2;
P1 = C_P;
end


%************************ P_f_d(s) ************************************
%**********************************************************************
function P_d = Poly_Coeff_d(P)
exp = size(P,2)-1:-1:1;
P(1:size(P,2)-1);
P_d(1:size(P,2)-1)=P(1:size(P,2)-1).*exp;
end

%***************************  H_f(s)  *********************************
%**********************************************************************
function H1 = Poly_Coeff_H(L_f,LAM_f,rho,Betas,C0)
C_H = [ ];
C_H(1)=dot(L_f,C0);
for j=2:size(L_f,2)
    s2=0;
    for i=1:size(L_f,2)
        s2 = s2+L_f(i)*C0(i)*Sumai(i,j-1,L_f);
    end
    C_H(j)=s2;
end
H1 = C_H;
end

%******************************* Q_f(s)  ******************************
%**********************************************************************
function Q1 = Poly_Coeff_Q(L_f)
C_Q = [ ];
C_Q(1)=1;
for j=1:size(L_f,2)
    C_Q(j+1)=Suma(j,L_f);
end
Q1=C_Q;
end
    
%********************************* Sums *******************************
%**********************************************************************
%Sum with replacement
function S1i = Sumai(i,m,L)
COPY = L;
COPY(i)=[];
S1i=Suma(m,COPY);
end

%Sum with replacement
function S1 = Suma(m,L)
COMB = nchoosek(L,m);
Vec = prod(COMB,2);
S1 = sum(Vec);
end

%************************** Analytic solution of precursors **************
%*************************************************************************
function Sol_C = Solution_C(n0,P,P_d,Q,H,t,alpha_f,L_f,Betas,LAM_f,C0)
r_P = roots(P);
Solution_C = [ ];
for j=1:size(Betas,2)
    s1 = 0;
    for k=1:size(r_P,1)
        Num = n0*polyval(Q,r_P(k))+polyval(H,r_P(k));
        Quot = polyval(P_d,r_P(k))*(r_P(k)+L_f(j));
        diff = ml(r_P(k)*(t^(alpha_f)),alpha_f)-ml(-L_f(j)*(t^(alpha_f)),alpha_f);
        s1 = s1+Num*diff/Quot;
    end
    Solution_C(j)=Betas(j)*(s1/LAM_f)+C0(j)*ml(-L_f(j)*(t^(alpha_f)),alpha_f);

end
Sol_C = Solution_C;
end

%****************** Analytic solution of the neutorn density************
%***********************************************************************
function Sol = Solution(n0,P,P_d,Q,H,t,alpha_f)
r_P = roots(P);
dime = size(r_P,1);
s1 = 0;
for k=1:size(r_P,1)
    Num = n0*polyval(Q,r_P(k))+polyval(H,r_P(k));
    Quot = polyval(P_d,r_P(k));
    raiz = r_P(k);
    Mittag = ml(raiz*(t^alpha_f),alpha_f);
    
    s1 = s1+Num*Mittag/Quot;
end
Sol = s1;

end

%************************* Iterative Solver *********************************
%******************************************************************

function R =Ramp(Target,L_f,LAM_f,Betas,h,Ramp,alpha_f,C0)
Vec_sol = [ ];
bet_tot = sum(Betas);
t=h;
n0=1;
for m=1:Target/h
    rho = (Ramp*bet_tot*m*t+Ramp*bet_tot*(m-1)*t)/2;
    solucion = 0;
    P = Poly_Coeff(L_f,LAM_f,rho,Betas);
    H = Poly_Coeff_H(L_f,LAM_f,rho,Betas,C0);
    Q = Poly_Coeff_Q(L_f);
    P_d =  Poly_Coeff_d(P);
    n_f = Solution(n0,P,P_d,Q,H,t,alpha_f);
    C_f = Solution_C(n0,P,P_d,Q,H,t,alpha_f,L_f,Betas,LAM_f,C0);
    n0 = n_f;
    C0=C_f;
    counter = [m Target/h];
    counter
    Vec_sol=[Vec_sol;t*m n_f C0];
end

R = Vec_sol
end

